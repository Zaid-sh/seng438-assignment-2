**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group: 5      |
|-----------------|
| Mohammed Zaid Shaikh                |
| Alexander Lai              |
| Odin Fox               |
| Aidan Gaede-Janke               |

# 1 Introduction

This lab aims to generate unit test cases for the Range and DataUtilities classes provided in the JFreeChart framework. Before this lab, we had a basic understanding of black-box testing including methods such as Equivalence Class Testing, Boundary Value Testing, Robustness Testing, and Category-Partition Testing. Black box testing refers to testing a system without any knowledge of the internal structures or workings. This allows thorough testing of the input and output of the software without being biased by the code structure.

Our goal in this lab was to apply the fundamentals learned in class and apply automated unit testing using JUnit and JMock to test for the requirements of the system. We have achieved a working understanding of JUnit, implementing black box testing techniques, and using Javadoc to develop edge test cases.

# 2 Detailed description of unit test strategy

Range.class testing was the simplier of the two classes being tested. Nothing beyond simple assert() statements were used in the testing of it's methods. Combined with the simplicity of the class, the methods chosen to be tested were simple as well, only needing a few assert statements in most situations. Due to the simplicity, testing didn't have to be incredibly thorough, only having to worry about a handful of edge cases across all methods.

DataUtilities was much more difficult to program from a testing perspective. Mock classes did have to be utilized in order to thoroughly test DataUtilities. Specifically, mocks were used to create objects for Values2D and KeyedValues, so that we can simulate the exact behaviors without requiring actual implementation. With the added complexity of the class, along came many more test cases that had to be considered and accounted for. Certain inputs with null values, strings, and no values were tested extensively within these tests. 

# 3 Test cases developed

### **DataUtilities.java:**

calculateRowTotal(Values2D data, int row):
- values > 0 (positive inputs)
- values < 0 (negative inputs)
- values == null (empty input)
- values are string types (invalid input)

createNumberArray(double[] data):
- data > 0 (positive array)
- data < 0 (negative array)
- data == null (empty array)

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

The work was divided first by the moudle that was being tested, betwween Range and DataUtilities. Then we split the funtions for each module where one person would do three functions and the other would do two.

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
